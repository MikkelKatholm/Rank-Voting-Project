# secure_ballot.mpc
import os, sys
sys.path.insert(0, os.path.dirname(sys.argv[0]) + '/..')

from Compiler.library import *
from Compiler.compilerLib import Compiler
from consts import *

compiler = Compiler()

@compiler.register_function('make_ballot')
def make_ballot(voter_id: int) -> Matrix:
    """Create a secret-shared ballot matrix from secret-shared priorities.
    
    :return: A NUM_CANDIDATES x NUM_CANDIDATES secret-shared ballot matrix. Each row i corresponds to candidate i, and each column j corresponds to priority j. Entry (i,j) is 1 if candidate i has priority j, else 0.

    Example:
    >>> make_ballot()
        If there are 3 candidates and the voter's secret priorities are [2, 0, 1]:
            Priority 0: Candidate 2
            Priority 1: Candidate 0
            Priority 2: Candidate 1  
        Then the resulting ballot matrix will be:
           [[0, 1, 0]  # Candidate 0 has priority 1
            [0, 0, 1]  # Candidate 1 has priority 2
            [1, 0, 0]] # Candidate 2 has priority 0
    """

    # Array to hold secret-shared priorities (one secret integer per candidate position)
    priorities = Array(NUM_CANDIDATES, sint)

    # Get secret input from party 0 (the voter). Each call returns a sint.
    # In an interactive/test run, party 0 must provide these inputs.
    priorities_from_file = sint.get_input_from(voter_id, size=NUM_CANDIDATES)
    
    for idx in range(NUM_CANDIDATES):
        priorities[idx] = priorities_from_file[idx]

    # Create a secret-shared matrix for the ballot (sint entries)
    ballot_matrix = Matrix(NUM_CANDIDATES, NUM_CANDIDATES, value_type=sint)

    # Build matrix using secure loops (i and j are regint)
    @for_range(NUM_CANDIDATES)
    def _(i):
        @for_range(NUM_CANDIDATES)
        def _(j):
            # compare secret priorities[j] with public i
            # Most mp-spdz implementations overload '==' for secret/public compare.
            # That returns a secret bit (sint or sbit-like) that we can use in an if_else.
            is_priority = (priorities[j] == i)

            # Convert the equality bit into 1/0 stored as sint
            # if_else(true_val, false_val) exists on many mp-spdz secret-bit objects.
            ballot_matrix[i][j] = is_priority.if_else(sint(1), sint(0))

    return ballot_matrix

def make_all_ballots() -> list[Matrix]:
    return [make_ballot(voter_id) for voter_id in range(NUM_VOTERS)]

def remove_eliminated_candidates(ballot: Matrix, active_candidates: Array) -> Matrix:
    """ Remove eliminated candidates from the ballot matrix. 
    
    :param ballot: A NUM_CANDIDATES x NUM_CANDIDATES secret-shared ballot matrix.
    :param active_candidates: A list of 0/1 secret-shared bits indicating active candidates.
    :return: A modified ballot matrix with eliminated candidates removed.
    """

    for row in range(NUM_CANDIDATES):
        for col in range(NUM_CANDIDATES):
            ballot[row][col] = ballot[row][col] * active_candidates[row]
    return ballot

def remove_non_highest_priority(ballot: Matrix) -> Matrix:
    """ Remove non-highest priority candidates from the ballot matrix.
    
    :param ballot: A NUM_CANDIDATES x NUM_CANDIDATES secret-shared ballot matrix.
    :return: A modified ballot matrix with only the highest priority candidate retained.

    Example:
    >>> remove_non_highest_priority(ballot)
        If the ballot matrix is:
           [[0, 0, 0]  # Candidate 0 is eliminated
            [0, 0, 1]  # Candidate 1 has priority 2
            [1, 0, 0]] # Candidate 2 has priority 0
        Then the resulting ballot matrix will be:
            [[0, 0, 0]  # Candidate 0 is eliminated
             [0, 0, 0]  # Candidate 1 is not highest priority
             [1, 0, 0]] # Candidate 2 is highest priority
    """
    found_highest = sint(1)
    @for_range(NUM_CANDIDATES)
    def _(col):
        @for_range(NUM_CANDIDATES)
        def _(row):
            is_highest = ballot[row][col] * (found_highest)
            ballot[row][col] = is_highest
            found_highest.update(found_highest - is_highest)

    return ballot

def eliminate_candidate(active_candidates: Array, cand_id: sint) -> Array:
    """ Eliminate a candidate by setting their active flag to 0
    
    :param active_candidates: A list of 0/1 secret-shared bits indicating active candidates.
    :param cand_id: The candidate ID to eliminate.
    :return: Updated active_candidates list with the specified candidate eliminated.
    """
    # NOTE: does this mean that a party can see how is eliminated based on what value is changed in active_candidates?


    @for_range(NUM_CANDIDATES)
    def _(i):
        condition = (i == cand_id)
        active_candidates[i] = condition.if_else(sint(0), sint(1) * active_candidates[i])

    return active_candidates

def initialize_active_candidates():
    """ Initialize all candidates as active (1). 
    :return: A list of secret-shared bits indicating all candidates are active.
    """
    active_candidates = Array(NUM_CANDIDATES, sint)
    active_candidates.assign_all(sint(1))
    return active_candidates

def sum_rows(ballot: Matrix) -> Array:
    """ Sum each row of the ballot matrix.
    
    :param ballot: A NUM_CANDIDATES x NUM_CANDIDATES secret-shared ballot matrix.
    :return: An array of secret-shared integers representing the sum of each row.
    """
    sum_of_rows = Array(NUM_CANDIDATES, sint)

    for row in range(NUM_CANDIDATES):
        row_sum = sint(0)
        for col in range(NUM_CANDIDATES):
            row_sum += ballot[row][col]
        sum_of_rows[row] = row_sum
    return sum_of_rows

def sum_vectors(vectors: list[Array]) -> Array:
    """ Sum a list of secret-shared integer arrays element-wise.
    
    :param vectors: A list of secret-shared integer arrays.
    :return: A single secret-shared integer array representing the element-wise sum.
    """
    result = Array(NUM_CANDIDATES, sint)
    result.assign_all(sint(0))

    for vector in vectors:
        @for_range(NUM_CANDIDATES)
        def _(i):
            condition = vector[i]
            result[i] = condition.if_else(result[i] + sint(1), result[i] + sint(0))
    
    return result

def majority(vector: Array) -> tuple[sint, Array]:
    """ Determine if any candidate has a majority and return the winner.
    :param vector: A secret-shared integer array representing candidate vote counts.
    :return: A tuple (has_majority, input) where has_majority is a secret-shared bit indicating if a candidate has majority, and winner_vector is a secret-shared bit array indicating the winning candidate.
    """
    has_majority = sint(0)
    @for_range(NUM_CANDIDATES)
    def _(i): 
        condition = (vector[i] > sint(NUM_VOTERS // 2))
        has_majority = condition.if_else(has_majority + sint(1), has_majority + sint(0))

    return has_majority, vector

def find_winner(vector: Array) -> sint:
    """ Find the candidate with the highest votes.
    :param vector: A secret-shared integer array representing candidate vote counts.
    :return: The candidate ID (sint) with the highest votes.
    """
    winner_id = sint(-1)

    @for_range(NUM_CANDIDATES)
    def _(i):
        is_winner = (vector[i] > sint(NUM_VOTERS // 2))
        winner_id.update(is_winner.if_else(sint(i), winner_id))

    return winner_id

def reveal_winner(winner_id: sint) -> int:
    """ Reveal the winning candidate ID to all parties.
    :param winner_id: The candidate ID (sint) to reveal.
    :return: The revealed candidate ID as an integer.
    """
    return winner_id.reveal()

def update_eliminated_candidates(vector: Array, active_candidates: Array) -> Array:
    """ Find the candidate with the lowest votes among active candidates.

    If there is a tie for lowest votes, the candidate with the lowest index is eliminated.

    :param vector: A secret-shared integer array representing candidate vote counts.
    :param active_candidates: A list of 0/1 secret-shared bits indicating active candidates.
    :return: A secret-shared bit array indicating the eliminated candidate.
    """
    smallest_value = sint(NUM_VOTERS + 1)
    smallest_index = sint(-1)

    @for_range(NUM_CANDIDATES)
    def _(i):
        # if active_candidates[i] == 1 => vector[i] = vector[i]
        # if active_candidates[i] == 0 => vector[i] = (NUM_CANDIDATES + 1) (large number)
        adjusted_value = vector[i] + (sint(1) - active_candidates[i]) * sint((NUM_CANDIDATES + 1))
        is_smallest = (adjusted_value < smallest_value)
        smallest_value.update(is_smallest.if_else(adjusted_value, smallest_value))
        smallest_index.update(is_smallest.if_else(sint(i), smallest_index))

    return eliminate_candidate(active_candidates, smallest_index)


def run_protocol():
    """ Run the RCV protocol. """
    ballots = make_all_ballots()
    active_candidates = initialize_active_candidates()
    winner = -1

    # Do a round
    for round in range(NUM_CANDIDATES):
        round_ballots: list[Matrix] = ballots[:]
        row_sums_array: list[Array] = []
        for ballot_id in range(NUM_VOTERS):
            round_ballots[ballot_id] = remove_eliminated_candidates(round_ballots[ballot_id], active_candidates)
            round_ballots[ballot_id] = remove_non_highest_priority(round_ballots[ballot_id])
            row_sums = sum_rows(round_ballots[ballot_id])
            row_sums_array.append(row_sums)
        vote_vector = sum_vectors(row_sums_array)
        if round < NUM_CANDIDATES - 1:
            active_candidates = update_eliminated_candidates(vote_vector, active_candidates)
        else:
            # Last round, find and reveal the winner
            winner_id = find_winner(vote_vector)
            winner = reveal_winner(winner_id)
    return winner

# Main function must be the lowest in the file!!!
@compiler.register_function('rcv_main')
def rcv_main():
    """Main function to create and process a secret-shared ballot matrix."""
    winner = run_protocol()
    print_ln_to(0, 'The winning candidate is: %s', winner)


if __name__ == "__main__":
    compiler.compile_func()
